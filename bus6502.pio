; Define the relative pin numbers

.define DATA_PIN  0
.define ADDR_PIN  8
.define RNW_PIN  11
.define CS_PIN   13
.define PHI2_PIN 14

; ====================================================================================
; PIO 0 - control
; ====================================================================================

; The bus6502_control program samples the address/data/rnw signals twice per access
; and pushes the result into the FIFO
;
; (4 + 4 + 3 + 5 = 16)

.program bus6502_control0
.wrap_target
public entry_point:
idle:
    wait 1 pin CS_PIN       ; wait for CS to go high
    wait 0 pin CS_PIN [7]   ; wait for CS to go low
                            ; delay ~50ns
    jmp pin, idle           ; deglitch CS
    irq set 0               ; irq 0 indicates CS has definitely been asserted
.wrap

; Test the RnW bit
.program bus6502_control1
read_cycle:
    irq set 1               ; irq 1 indicates a read cycle occurred
.wrap_target
public entry_point:
    wait 1 irq 0            ; wait for irq 0, and clear it
    jmp pin, read_cycle     ; test the RnW bit
    irq set 2               ; irq 2 triggers the capture
.wrap

; Test the A0 bit
.program bus6502_control2
read_cycle:
    irq set 2               ; irq 2 triggers the capture
.wrap_target
public entry_point:
    wait 1 irq 1            ; wait for irq 1, and clear it
    jmp pin, read_cycle     ; if A0=1 (non-status) then capture
.wrap

; Capture the GPIOs
.program bus6502_control3
.wrap_target
public entry_point:
    wait 1 irq 2            ; wait for irq 2 and clear it
    wait 1 pin PHI2_PIN [20]; wait for PHI2 pin to go high
                            ; delay 150ns
    in pins, 16             ; sample the gpio towards the end of Phase 2
    wait 0 pin PHI2_PIN     ; wait for PHI2 pin to go low
    push                    ; push sample into the Rx FIFO
.wrap                       ; and back to idle again

; ====================================================================================
; PIO 1 - read cycle
; ====================================================================================


; The bus6502_pindirs progam sets the direction of 4-bits of the data bus
; (two state machines are needed to cover the full 8-bit data bus)
;
; (9)

.program bus6502_pindirs
read_cycle:
    mov osr, ~x             ; osr = 0xffffffff
    out pindirs, 8          ; start driving the databus
    wait 0 pin PHI2_PIN     ; wait for the end of the bus cycle
    mov osr, x              ; osr = 0x00000000
    out pindirs, 8          ; start driving the databus
public entry_point:
.wrap_target
idle:
    wait 1 pin CS_PIN       ; wait for CS to go high
    wait 0 pin CS_PIN       ; wait for CS to go low
                            ; TODO deglitch CS and add a bit of delay
    wait 1 pin PHI2_PIN     ; wait for PHI2 pin to go high
    jmp pin read_cycle      ; the EXECCTRL_JMP_PIN is RNW
.wrap                       ; and back to idle again


; The bus6502_a2 program waits for the falling edge of CS, then samples a2
; If a2=0 then irq 2 is set to trigger the pins program running on SM2
; If a2=1 then irq 3 is set to trigger the pins program running on SM2
;
; (5)

.program bus6502_a2
a2high:
    irq set 3
public entry_point:
.wrap_target
idle:
    wait 1 pin CS_PIN       ; wait for CS to go high (-8 as the input mapping excludes D7:0)
    wait 0 pin CS_PIN [5]   ; wait for CS to go low
                            ; delay a bit
    jmp pin, a2high         ; sample the a2 pin, and set irq 2/3 accordingly
    irq set 2
.wrap


; The bus6502_pins programs selects the approriate 8-bits out of 32-bit osr,
; and writes this to the the data bus
;
; two copies of this will be deployed, controller be different irq bits
;
; (9)

.program bus6502_pins
public entry_point:
.wrap_target
idle:
    wait 1 irq 0 rel        ; wait on irq 2 (sm2) or irq3 (sm3)
    in pins, 2              ; right-shift the lower two address bits into isr
    in null, 30             ; right-shift a further 30 zeros so address is correctly aligned
    mov y, isr              ; copy 2-bit address into y
    mov isr, osr            ; copy 32-bit osr (holding the read data) into the isr
loop:                       ; while y != 0
    jmp !y, done            ;
    in null, 8              ; shift the isr right by 8-bits
    jmp y--, loop           ; decrement the address, and loop back
done:
    mov pins, isr           ; write the lower 8 bits of the isr to the databus
.wrap                       ; and back to idle again
