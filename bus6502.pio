; Define the relative pin numbers

.define DATA_PIN  0
.define ADDR_PIN  8
.define RNW_PIN  11
.define CS_PIN   13
.define PHI2_PIN 14

; ====================================================================================
; PIO 0 - control
; ====================================================================================

; The bus6502_control program samples the address/data/rnw signals twice per access
; and pushes the result into the FIFO
;
; (4 + 4 + 3 + 5 = 16)

.program bus6502_control0
.wrap_target
public entry_point:
idle:
    wait 1 pin CS_PIN       ; wait for CS to go high
    wait 0 pin CS_PIN [7]   ; wait for CS to go low
                            ; delay ~50ns
    jmp pin, idle           ; deglitch CS
    irq set 0               ; irq 0 indicates CS has definitely been asserted
.wrap

; Test the RnW bit
.program bus6502_control1
read_cycle:
    irq set 1               ; irq 1 indicates a read cycle occurred
.wrap_target
public entry_point:
    wait 1 irq 0            ; wait for irq 0, and clear it
    jmp pin, read_cycle     ; test the RnW bit
    irq set 2               ; irq 2 triggers the capture
.wrap

; Test the A0 bit
.program bus6502_control2
read_cycle:
    irq set 2               ; irq 2 triggers the capture
.wrap_target
public entry_point:
    wait 1 irq 1            ; wait for irq 1, and clear it
    jmp pin, read_cycle     ; if A0=1 (non-status) then capture
.wrap

; Capture the GPIOs
.program bus6502_control3
.wrap_target
public entry_point:
    wait 1 irq 2            ; wait for the capture trigger
    in pins, 16             ; take a sample when the control signals are stable
    wait 1 pin PHI2_PIN     ; wait for PHI2 pin to go high
    wait 0 pin PHI2_PIN     ; wait for PHI2 pin to go low
    in pins, 16             ; sample the write data just after the falling edge
    push                    ; push sample into the Rx FIFO
.wrap                       ; and back to idle again


; ====================================================================================
; PIO 1 - read cycle
; ====================================================================================


; The bus6502_pindirs progam sets the direction of 4-bits of the data bus
; (two state machines are needed to cover the full 8-bit data bus)
;
; (9)

.program bus6502_pindirs
read_cycle:
    mov osr, ~x             ; osr = 0xffffffff
    out pindirs, 8          ; start driving the databus
    wait 0 pin PHI2_PIN     ; wait for the end of the bus cycle
    mov osr, x              ; osr = 0x00000000
    out pindirs, 8          ; start driving the databus
public entry_point:
.wrap_target
idle:
    wait 1 pin CS_PIN       ; wait for CS to go high
    wait 0 pin CS_PIN       ; wait for CS to go low
                            ; TODO deglitch CS and add a bit of delay
    wait 1 pin PHI2_PIN     ; wait for PHI2 pin to go high
    jmp pin read_cycle      ; the EXECCTRL_JMP_PIN is RNW
.wrap                       ; and back to idle again

; The bus6502_pins0 programs selects the approriate 8-bits out of 32-bit x,
; and write this to the the data bus (specifically the output register)
;
; this is used when a2 = 0
;
; (9)

.program bus6502_pins0
public entry_point:
.wrap_target
idle:
    in null, 32             ; make sure the ISR is clear
    wait 1 pin (CS_PIN-8)   ; wait for CS to go high (-8 as the input mapping excludes D7:0)
    wait 0 pin (CS_PIN-8)   ; wait for CS to go low
                            ; TODO deglitch CS and add a bit of delay
    in pins, 2              ; sample the lower two address bits into isr

    jmp pin, idle           ; if a2=1 then loop back

    mov y, isr              ; copy 2-bit address into y
    mov osr, x              ; copy 32-bit x (holding the read data) into the osr
loop:
    out pins, 8             ; copy the lower 8 bits of the osr to data bus
    jmp y--, loop           ; decrement the address, and loop back
.wrap                       ; and back to idle again

; The bus6502_pins0 programs selects the approriate 8-bits out of 32-bit x,
; and write this to the the data bus (specifically the output register)
;
; this is used when a2 = 1
;
; (9)

.program bus6502_pins1
read_cycle:
    mov y, isr              ; copy 2-bit address into y
    mov osr, x              ; copy 32-bit x (holding the read data) into the osr
loop:
    out pins, 8             ; copy the lower 8 bits of the osr to data bus
    jmp y--, loop           ; decrement the address, and loop back
public entry_point:
.wrap_target
idle:
    in null, 32             ; make sure the ISR is clear
    wait 1 pin (CS_PIN-8)   ; wait for CS to go high (-8 as the input mapping excludes D7:0)
    wait 0 pin (CS_PIN-8)   ; wait for CS to go low
                            ; TODO deglitch CS and add a bit of delay
    in pins, 2              ; sample the lower two address bits into isr

    jmp pin, read_cycle     ; if a2=0 then loop back
.wrap                       ; and back to idle again
